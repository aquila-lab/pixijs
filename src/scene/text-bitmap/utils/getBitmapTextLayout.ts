import type { TextStyle } from '../../text/TextStyle';
import type { AbstractBitmapFont } from '../AbstractBitmapFont';

/**
 * The layout data for a bitmap text.
 * This contains the width, height, scale, offsetY and lines of text.
 * Each line contains its width, character positions, characters, space width and spaces index.
 * @category text
 * @internal
 */
export interface BitmapTextLayoutData
{
    width: number;
    height: number;
    scale: number;
    offsetY: number;
    lines: {
        width: number
        charPositions: number[],
        chars: string[],
        // / spaces: number
        spaceWidth: number
        spacesIndex: number[]
    }[];
}

/**
 * @param chars
 * @param style
 * @param font
 * @param trimEnd
 * @internal
 */
export function getBitmapTextLayout(
    chars: string[],
    style: TextStyle,
    font: AbstractBitmapFont<any>,
    trimEnd: boolean
): BitmapTextLayoutData
{
    const layoutData: BitmapTextLayoutData = {
        width: 0,
        height: 0,
        offsetY: 0,
        scale: style.fontSize / font.baseMeasurementFontSize,
        lines: [{
            width: 0,
            charPositions: [] as number[],
            spaceWidth: 0,
            spacesIndex: [],
            chars: [],
        }]
    };

    layoutData.offsetY = font.baseLineOffset;

    let currentLine = layoutData.lines[0];

    let previousChar: string = null;
    let firstWord = true;
    //    let spaceCount = 0;

    const currentWord = {
        spaceWord: false,
        width: 0,
        start: 0,
        index: 0, // use index to not modify the array as we use it a lot!
        positions: [] as number[],
        chars: [] as string[],
    };

    const scale = font.baseMeasurementFontSize / style.fontSize;

    const adjustedLetterSpacing = style.letterSpacing * scale;
    const adjustedWordWrapWidth = style.wordWrapWidth * scale;
    const adjustedLineHeight = (style.lineHeight !== null && style.lineHeight !== undefined)
        ? style.lineHeight * scale
        : font.lineHeight;

    const breakWords = style.wordWrap && style.breakWords;

    const nextWord = (word: typeof currentWord) =>
    {
        const start = currentLine.width;

        for (let j = 0; j < currentWord.index; j++)
        {
            const position = word.positions[j];

            currentLine.chars.push(word.chars[j]);
            currentLine.charPositions.push(position + start);
        }

        currentLine.width += word.width;

        firstWord = false;

        // reset the word..
        currentWord.width = 0;
        currentWord.index = 0;
        currentWord.chars.length = 0;

        // spaceCount = 0;
    };

    const nextLine = () =>
    {
        let index = currentLine.chars.length - 1;

        if (trimEnd)
        {
            let lastChar = currentLine.chars[index];

            while (lastChar === ' ')
            {
                currentLine.width -= font.chars[lastChar].xAdvance;
                lastChar = currentLine.chars[--index];
            }
        }

        layoutData.width = Math.max(layoutData.width, currentLine.width);

        currentLine = {
            width: 0,
            charPositions: [],
            chars: [],
            spaceWidth: 0,
            spacesIndex: [],
        };

        firstWord = true;
        layoutData.lines.push(currentLine);
        layoutData.height += adjustedLineHeight;
    };

    const checkIsOverflow = (lineWidth: number) =>
        lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;

    // Characters that allow breaking AFTER them (like CSS line-break opportunities)
    // These characters stay with the current word, then we can wrap to a new line
    // Used when wordWrap is enabled to provide CSS break-word behavior
    const isBreakAfterChar = (c: string) =>
        c === '-' // hyphen
        || c === '\u2010' // hyphen (Unicode)
        || c === '\u2013' // en-dash
        || c === '\u2014' // em-dash
        || c === '\u00AD'; // soft hyphen

    // loop an extra time to force a line break..
    for (let i = 0; i < chars.length + 1; i++)
    {
        let char: string;

        const isEnd = i === chars.length;

        if (!isEnd)
        {
            char = chars[i];
        }

        const charData = font.chars[char] || font.chars[' '];

        const isSpace = (/(?:\s)/).test(char);
        const isNewline = char === '\r' || char === '\n';
        // Break-after chars (hyphen, dot, slash) - char stays with word, then we can break
        // Only applies when breakWords is FALSE (CSS break-word behavior)
        // When breakWords is TRUE (CSS break-all), we break at any character instead
        const isBreakAfter = !isEnd && style.wordWrap && !breakWords && isBreakAfterChar(char);
        // Traditional word breaks (spaces, newlines, end)
        const isWordBreak = isSpace || isNewline || isEnd;

        // For break-after chars, add to word first, then treat as word break
        if (isBreakAfter)
        {
            const kerning = charData.kerning[previousChar] || 0;
            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;

            currentWord.positions[currentWord.index++] = currentWord.width + kerning;
            currentWord.chars.push(char);
            currentWord.width += nextCharWidth;

            previousChar = char;
        }

        // Handle word breaks (spaces, newlines, end, or after break-after chars)
        if (isWordBreak || isBreakAfter)
        {
            const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);

            if (addWordToNextLine)
            {
                nextLine();

                nextWord(currentWord);

                if (!isEnd && !isBreakAfter)
                {
                    currentLine.charPositions.push(0);
                }
            }
            else
            {
                currentWord.start = currentLine.width;

                nextWord(currentWord);

                if (!isEnd && !isBreakAfter)
                {
                    currentLine.charPositions.push(0);
                }
            }

            if (isNewline)
            {
                nextLine();
            }
            else if (isSpace && !isEnd)
            {
                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;

                currentLine.width += spaceWidth;

                currentLine.spaceWidth = spaceWidth;
                currentLine.spacesIndex.push(currentLine.charPositions.length);
                currentLine.chars.push(char);
            }

            if (!isBreakAfter)
            {
                previousChar = char;
            }
        }
        else
        {
            // Regular character - add to current word
            const kerning = charData.kerning[previousChar] || 0;
            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;

            if (style.wordWrap && currentWord.index > 0)
            {
                if (breakWords)
                {
                    // breakWords: true = CSS break-all
                    // Break when line + word + char would overflow
                    const wouldOverflow = checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);

                    if (wouldOverflow)
                    {
                        nextWord(currentWord);
                        nextLine();
                    }
                }
                else
                {
                    // breakWords: false = CSS break-word
                    // Break as last resort when word ALONE is too long (no break-after chars helped)
                    const wordAloneTooLong = checkIsOverflow(currentWord.width + nextCharWidth);

                    if (wordAloneTooLong)
                    {
                        // Word is genuinely too long for any line, break it
                        if (checkIsOverflow(currentLine.width + currentWord.width))
                        {
                            nextLine();
                        }
                        nextWord(currentWord);
                        nextLine();
                    }
                }
            }

            currentWord.positions[currentWord.index++] = currentWord.width + kerning;
            currentWord.chars.push(char);
            currentWord.width += nextCharWidth;

            previousChar = char;
        }
    }

    nextLine();

    // Ensure minimum height based on font metrics for proper hit testing.
    // lineHeight controls line spacing, but bounds should always include actual text height.
    layoutData.height = Math.max(layoutData.height, font.lineHeight);

    if (style.align === 'center')
    {
        alignCenter(layoutData);
    }
    else if (style.align === 'right')
    {
        alignRight(layoutData);
    }
    else if (style.align === 'justify')
    {
        alignJustify(layoutData);
    }

    return layoutData;
}

function alignCenter(measurementData: BitmapTextLayoutData)
{
    for (let i = 0; i < measurementData.lines.length; i++)
    {
        const line = measurementData.lines[i];
        const offset = ((measurementData.width / 2) - (line.width / 2));

        for (let j = 0; j < line.charPositions.length; j++)
        {
            line.charPositions[j] += offset;
        }
    }
}

function alignRight(measurementData: BitmapTextLayoutData)
{
    for (let i = 0; i < measurementData.lines.length; i++)
    {
        const line = measurementData.lines[i];
        const offset = ((measurementData.width) - (line.width));

        for (let j = 0; j < line.charPositions.length; j++)
        {
            line.charPositions[j] += offset;
        }
    }
}

function alignJustify(measurementData: BitmapTextLayoutData)
{
    const width = measurementData.width;

    for (let i = 0; i < measurementData.lines.length; i++)
    {
        const line = measurementData.lines[i];

        let indy = 0;
        let spaceIndex = line.spacesIndex[indy++];

        let offset = 0;

        const totalSpaces = line.spacesIndex.length;

        const newSpaceWidth = (width - line.width) / totalSpaces;

        const spaceWidth = newSpaceWidth;

        for (let j = 0; j < line.charPositions.length; j++)
        {
            if (j === spaceIndex)
            {
                spaceIndex = line.spacesIndex[indy++];

                offset += spaceWidth;
            }

            line.charPositions[j] += offset;
        }
    }
}
